#include <TROOT.h>
#include <TCanvas.h>
#include <TF1.h>
#include <TMath.h>
#include <iostream>
#include <vector>
#include <string>
#include <utility>
#include <TGraphErrors.h>
#include <TLegend.h>
#include <TAxis.h>
#include <TColor.h>
#include "TLine.h"

#include <fstream>
#include <sstream>
#include "TH1D.h"
#include "TFile.h"
#include <cmath>
#include "TH1D.h"
#include "TFile.h"




 void drawHistograms(TH1* hist1, TH1* hist2, TH1* hist3, TH1* hist4, 
                    const std::string& outputFileName, const std::string& customText) { 
    TCanvas* canvasss = new TCanvas("canvasss", "Histograms");
    canvasss->cd();
    canvasss->SetLogx(); 
    canvasss->Update();

    TH1F* frame3 = gPad->DrawFrame(0.01, 0., 1., hist4->GetMaximum() * 1.1);
    frame3->GetXaxis()->SetTitle("R_{L}");
    std::string yAxisTitle = customText;
    frame3->GetYaxis()->SetTitle(yAxisTitle.c_str());

    hist1->SetLineColor(kGreen +4);
    hist2->SetLineColor(kRed);
    hist3->SetLineColor(kBlue);
    hist4->SetLineColor(kOrange +3);
    hist1->Draw("E SAME"); 
    hist2->Draw("E SAME"); 
    hist3->Draw("E SAME");
    hist4->Draw("E SAME");

    TLegend* l = new TLegend(0.6, 0.6, 0.9, 0.9); 
    l->AddEntry(hist1, "Simulation (40-60 GeV/c)", "l");
    l->AddEntry(hist2, "Simulation (60-80 GeV/c)", "l");
    l->AddEntry(hist3, "Alice data (40-60 GeV/c)", "l");
    l->AddEntry(hist4, "Alice data (60-80 GeV/c)", "l");
    l->Draw();

    canvasss->Update(); 
    canvasss->SaveAs(outputFileName.c_str());
    delete canvasss;
}



struct DataPoint {
    double Rl;
    double Sigma;
    double sys_unc_plus;
    double sys_unc_minus;
};

std::vector<DataPoint> readDataFromFile(const std::string& filePath, const std::string& ptRange) {
    std::vector<DataPoint> data;
    std::ifstream file(filePath);
    std::string line;
    bool startReading = false;
    
    while (std::getline(file, line)) {
        if (line.find("#: $" + ptRange) != std::string::npos) {
            startReading = true;
            continue;
        }

        if (startReading && line.find("#:") != std::string::npos && line.find("#: $" + ptRange) == std::string::npos) {
            break;
        }

        if (startReading && line.find("#: $R_{L}$") != std::string::npos) {
            continue;
        }

        if (startReading && !line.empty() && line[0] != '#') {
            std::istringstream ss(line);
            DataPoint dp;
            char comma;

            if (ss >> dp.Rl >> comma >> dp.Sigma >> comma >> dp.sys_unc_plus >> comma >> dp.sys_unc_minus) {
                data.push_back(dp);
            } else {
                std::cerr << "Error parsing line: " << line << std::endl;
            }
        }
    }
    return data;
}


void DrawEEC(
    TH1* g19az0,
    TH1* g19bz0,
    TH1* g19cz0,
    TH1* g19dz0,
    const std::string& title,
    const std::string& outputFileName
) {
    TCanvas* kg = new TCanvas("kg", title.c_str());
    kg->cd();
    kg->SetLogx();

    double x_min = 1e-3; // Frame minimum x value
    double x_max = 1;    // Frame maximum x value
    double y_max = g19az0->GetMaximum() * 1.1;

    TH1F *frame = gPad->DrawFrame(x_min, 0, x_max, y_max);
    frame->GetXaxis()->SetTitle("R_{L}");
    frame->GetYaxis()->SetTitle("#Sigma_{EEC}(R_{L})");

    g19az0->SetLineColor(kBlue);
    g19bz0->SetLineColor(kOrange+4);
    g19cz0->SetLineColor(kRed);
    g19dz0->SetLineColor(kBlack);

    g19az0->GetXaxis()->SetRangeUser(x_min, x_max);
    g19bz0->GetXaxis()->SetRangeUser(x_min, x_max);
    g19cz0->GetXaxis()->SetRangeUser(x_min, x_max);
    g19dz0->GetXaxis()->SetRangeUser(x_min, x_max);

    g19az0->Draw("E same");
    g19bz0->Draw("E same");
    g19cz0->Draw("E same");
    g19dz0->Draw("E same");

    TLegend* l19a = new TLegend(0.7, 0.68, 1.0, 0.98); 
    l19a->AddEntry(g19az0, "(40, 60) Gev/c", "l");
    l19a->AddEntry(g19bz0, "(60, 80) Gev/c", "l");
    l19a->AddEntry(g19cz0, "(80, 100) Gev/c", "l");
    l19a->AddEntry(g19dz0, "(100, 120) Gev/c", "l");
    l19a->Draw();

    kg->SaveAs(outputFileName.c_str());

    delete kg;
}



void DrawScaledEEC(
    TH1* g19az1s,
    TH1* g19bz1s,
    TH1* g19cz1s,
    TH1* g19dz1s,
    const std::string& title,
    const std::string& outputFileName,
    double final_peak,
    double peak_error
) {
    TCanvas* kgg = new TCanvas("kgg", title.c_str(), 1000, 700);
    kgg->cd();
    kgg->SetLogx();

    TH1F *frame = gPad->DrawFrame(0.1, 0, 30, g19az1s->GetMaximum() * 1.1);
    frame->GetXaxis()->SetTitle("#LTp_{T}^{ch,jet}#GT R_{L} (GeV/c)");
    frame->GetYaxis()->SetTitle("#Sigma_{EEC}(R_{L})");
    frame->GetXaxis()->SetTitleOffset(1.3);

    TLine* peakLine = new TLine(final_peak, 0, final_peak, g19az1s->GetMaximum());
    TLine* peakLine_er = new TLine(final_peak, 0, final_peak, g19az1s->GetMaximum());
    peakLine->SetLineColor(kGreen+4);
    peakLine->SetLineStyle(0); 
    peakLine->SetLineWidth(1); 
    peakLine_er->SetLineColor(kGray);
    peakLine_er->SetLineStyle(0); 
    peakLine_er->SetLineWidth(peak_error*2); 
    peakLine_er->Draw(); 
    peakLine->Draw("Esame"); 

    g19az1s->SetLineColor(kBlue);
    g19az1s->SetTitle("");
    g19az1s->SetStats(0);
    g19bz1s->SetLineColor(kOrange+3);
    g19cz1s->SetLineColor(kRed);
    g19dz1s->SetLineColor(kBlack);

    g19az1s->Draw("Esame");
    g19bz1s->Draw("Esame");
    g19cz1s->Draw("Esame");
    g19dz1s->Draw("Esame");

    TLatex latex; 
    latex.SetNDC();  
    latex.SetTextSize(0.04);  
    latex.SetTextFont(42);

    double x = 0.15; 
    double y = 0.85; 
    double lineX1 = x;            
    double lineX2 = x + 0.07;      
    TLine *line = new TLine(lineX1, y, lineX2, y); 
    line->SetNDC();            
    line->SetLineColor(kGreen+4);      
    line->SetLineWidth(2);        
    line->Draw();

    latex.SetTextSize(0.035);      
    TString fitText = Form("Peak = %.2f #pm %.2f", final_peak, peak_error);
    latex.DrawLatex(lineX2 + 0.02, y, fitText); 


    TLegend* l19as = new TLegend(0.7, 0.65, 1.0, 0.95);
    l19as->AddEntry(g19az1s, "(40, 60) GeV/c", "l");
    l19as->AddEntry(g19bz1s, "(60, 80) GeV/c", "l");
    l19as->AddEntry(g19cz1s, "(80, 100) GeV/c", "l");
    l19as->AddEntry(g19dz1s, "(100, 120) GeV/c", "l");
    l19as->Draw();

    kgg->SaveAs(outputFileName.c_str());
    delete kgg;
}

    std::pair<double, double> GausFit(TH1 *h1, double pt_av, const std::string &output_filename, double nl = 0.4, double nr = 0.4, double initialMean = 0.07) {

    TF1 *f1 = new TF1("g1", "gaus", h1->GetXaxis()->GetXmin(), h1->GetXaxis()->GetXmax());

    // Initial parameter estimates
    double mean = initialMean;
    double sigma = h1->GetRMS();

    // First fit
    h1->Fit(f1, "R0I", "", mean - nl * sigma, mean + nr * sigma);
    sigma = f1->GetParameter(2);
    mean = f1->GetParameter(1);
    Printf("--1st fit mean: %f, sigma: %f", mean, sigma);

    // Iterative fitting loop
    int maxIter = 10;
    double meanOld = mean;
    for (int i = 0; i < maxIter; ++i) {
        meanOld = mean;

        h1->Fit(f1, "R0I", "", mean - nl * sigma, mean + nr * sigma);
        sigma = f1->GetParameter(2);
        mean = f1->GetParameter(1);
        f1->SetRange(mean - nl * sigma, mean + nr * sigma);
        if (fabs(mean - meanOld) < 0.001) break;
    }

    // Retrieve final fit results
    double peak = f1->GetParameter(1);  // Mean
    double scaledPeak = peak * pt_av;
    double peakError = f1->GetParError(1);  // Error in mean
    double scaledPeakError = peakError * pt_av;
    double reducedChi2 = f1->GetChisquare()/f1->GetNDF();

    // Print final results
    Printf("Final reduced Chi = %f", reducedChi2);
    Printf("The final peak of the Gaussian fit (mu) is: %f +/- %f", scaledPeak, scaledPeakError);

    std::vector<std::pair<double, double>> intervals = {
        {40, 60},
        {60, 80},
        {80, 100},
        {100, 120}
    };

    // Variables for bounds
    double lower_pt_bound = 0;
    double upper_pt_bound = 0;
    bool found = false;

    // Check which interval the value belongs to
    for (const auto& interval : intervals) {
        if (pt_av >= interval.first && pt_av < interval.second) {
            lower_pt_bound = interval.first;
            upper_pt_bound = interval.second;
            found = true;
            break;
        }
    }

    // Draw histogram with fit
    auto canvas = std::make_unique<TCanvas>("canvas", "Gaussian Fit", 800, 600);
    //canvas->SetLogx();
    h1->SetTitle("");
    h1->SetStats(0);
    h1->GetXaxis()->SetTitle("R_{L}");
    h1->GetYaxis()->SetTitle("#Sigma_{EEC}(R_{L})");
    //h1->GetXaxis()->SetRangeUser(1e-3, 1);
    h1->Draw();
    f1->Draw("SAME");

    // Add text in corner image
    TLatex latex;
    latex.SetNDC();  
    latex.SetTextSize(0.04);  
    latex.SetTextFont(42);    
    latex.SetTextAlign(31);   
    double x = 0.85; 
    double y = 0.85; 
    latex.DrawLatex(x, y, "Anti-k_{T} jets, R = 0.4, |#eta_{jet}| < 2");
    y -= 0.05; 
    TString rangeText = Form("%.0f < p_{T,jet}^{ch} < %.0f GeV/c", lower_pt_bound, upper_pt_bound);
    //rangeText += ", p_{T,track} > 1 GeV/c"; // for hadron fits
    latex.DrawLatex(x, y, rangeText);
    y -= 0.05; 
    latex.SetTextSize(0.035);  
    latex.DrawLatex(x, y, "Fit peak with Gaus(R_{L})");

    canvas->SaveAs(output_filename.c_str());

    // Clean up
    delete f1;

    return std::make_pair(scaledPeak, scaledPeakError);
    }


std::pair<double, double> LinearFit(
    const std::vector<double>& pt_av1, 
    const std::vector<double>& scaled_dr_peak, 
    const std::vector<double>& scaled_dr_peak_error, 
    const std::string& outputFileName = "linear_fit_with_errors.png",
    double x = 0.15 , double y= 0.85) 
{
    int n = pt_av1.size(); 
    //std::vector<double> pt_av_binwidth = {20, 20, 20, 20};
    TGraphErrors* graph = new TGraphErrors(n, &pt_av1[0], &scaled_dr_peak[0], nullptr, &scaled_dr_peak_error[0]);

    TF1* linearFit = new TF1("linearFit", "[0]", 100, 250); 
    graph->Fit(linearFit, "Q"); 
    double fittedRlPeak = linearFit->GetParameter(0);
    double fittedRlPeakError = linearFit->GetParError(0);

    TCanvas* canvas = new TCanvas("canvas", "Linear Fit", 800, 600);
    //graph->GetYaxis()->SetRangeUser(2, 4);
    graph->SetMarkerStyle(20);
    graph->SetTitle("");
    graph->GetXaxis()->SetTitle("#LTp_{T,jet}^{ch}#GT (GeV/c)");
    graph->GetYaxis()->SetTitle("#LTp_{T}^{ch,jet}#GT R_{L,peak} (GeV/c)");
    graph->Draw("AP"); 
    linearFit->Draw("same");

    TLatex latex;
    latex.SetNDC();  
    latex.SetTextSize(0.04);  
    latex.SetTextFont(42);  

    latex.DrawLatex(x, y, "Anti-k_{T} jets, R = 0.4, |#eta_{jet}| < 2"); 
    y -= 0.05; 

    TLine *line = new TLine(x , y, x + 0.05, y); 
    line->SetNDC();   
    line->SetLineColor(kRed); 
    line->SetLineWidth(2);    
    line->Draw();
    latex.SetTextSize(0.035);  
    TString fitText = Form("Fit function = %.2f #pm %.2f", fittedRlPeak, fittedRlPeakError);
    latex.DrawLatex(x + 0.07, y, fitText);

    canvas->SaveAs(outputFileName.c_str());

    delete graph;
    delete linearFit;
    delete canvas;
    return std::make_pair(fittedRlPeak, fittedRlPeakError);
}


void plots() {



    
    TFile *f1 = new TFile("JetToyResultslowerpt.root");


   
 // Plots for Counter

    // 2D plot E2C vs dr12 for 2 zcuts
    TH2 *g9 = dynamic_cast<TH2*>(f1->Get("hSplitZcut1E2C_vs_dr12"));
    TH2 *g10 = dynamic_cast<TH2*>(f1->Get("hSplitE2C_vs_dr12"));
    TH2 *g11 = dynamic_cast<TH2*>(f1->Get("hSplitZcut2E2C_vs_dr12"));

    TCanvas *k6 = new TCanvas("k6", "k6", 1800, 600); 
    gStyle->SetPalette(kRainBow); 
    k6->Divide(3, 1);  
    k6->cd(1);         
    g10->Draw("COLZ"); 
    k6->cd(2);         
    g9->Draw("COLZ"); 
    k6->cd(3);
    g11->Draw("COLZ");

    k6->SaveAs("hSplitE2C_vs_dr12.png");

    //2D plot for log(z*dr12) vs log(1/dr12) for 2 zcuts
    TH2 *g12= dynamic_cast<TH2*>(f1->Get("Lund plane with applied Zcut1"));
    TH2 *g13= dynamic_cast<TH2*>(f1->Get("Lund plane with applied Zcut2"));
    TH2 *g14= dynamic_cast<TH2*>(f1->Get("Lund plane without Zcut"));

    TCanvas *k7 = new TCanvas("k7", "k7", 3000, 800); 
    k7->Divide(3, 1); 

    // First plot (without Zcut)
    k7->cd(1);
    gPad->SetRightMargin(0.15); 
    g14->SetTitle("");
    g14->SetStats(0);
    g14->GetXaxis()->SetTitle("log(1 / #theta)");
    g14->GetYaxis()->SetTitle("log(z * #theta)");
    g14->GetXaxis()->SetTitleSize(0.03);
    g14->GetYaxis()->SetTitleSize(0.03);
    g14->GetXaxis()->SetLabelSize(0.03);
    g14->GetYaxis()->SetLabelSize(0.03);
    g14->Draw("COLZ");

    // Second plot (with Zcut1)
    k7->cd(2);
    gPad->SetRightMargin(0.15); 
    g12->SetTitle("");
    g12->SetStats(0);
    g12->GetXaxis()->SetTitle("log(1 / #theta)");
    g12->GetYaxis()->SetTitle("log(z * #theta)");
    g12->GetXaxis()->SetTitleSize(0.03);
    g12->GetYaxis()->SetTitleSize(0.03);
    g12->GetXaxis()->SetLabelSize(0.03);
    g12->GetYaxis()->SetLabelSize(0.03);
    g12->Draw("COLZ");

    // Third plot (with Zcut2)
    k7->cd(3);
    gPad->SetRightMargin(0.15); 
    g13->SetTitle("");
    g13->SetStats(0);
    g13->GetXaxis()->SetTitle("log(1 / #theta)");
    g13->GetYaxis()->SetTitle("log(z * #theta)");
    g13->GetXaxis()->SetTitleSize(0.03);
    g13->GetYaxis()->SetTitleSize(0.03);
    g13->GetXaxis()->SetLabelSize(0.03);
    g13->GetYaxis()->SetLabelSize(0.03);
    g13->Draw("COLZ");

    gStyle->SetLabelSize(0.04, "Z"); 
    gStyle->SetTitleSize(0.05, "Z");

    k7->SaveAs("hSplitlogzdr_vs_dr12.png");



    //----------------------------------------------------------
    // Histograms EEC pt intervals for hadrons 
    //----------------------------------------------------------

    TH1 *g18a= dynamic_cast<TH1*>(f1->Get("hE2C_sum_vs_dr12_pi1"));
    TH1 *g18b= dynamic_cast<TH1*>(f1->Get("hE2C_sum_vs_dr12_pi2"));
    TH1 *g18c= dynamic_cast<TH1*>(f1->Get("hE2C_sum_vs_dr12_pi3"));
    TH1 *g18d= dynamic_cast<TH1*>(f1->Get("hE2C_sum_vs_dr12_pi4"));

   TCanvas* ks = new TCanvas("ks", "ks");
    ks->cd();
    ks->SetLogx(); 

    double x_min = 1e-3; // Minimum x-value
    double x_max = 1;    // Maximum x-value
    double y_max = g18a->GetMaximum() * 1.1; // Maximum y-value based on the highest data point in g18a

    TH1F* frame1 = gPad->DrawFrame(x_min, 0, x_max, y_max);
    frame1->GetXaxis()->SetTitle("R_{L}");
    frame1->GetYaxis()->SetTitle("#Sigma_{EEC}(R_{L})");

    g18a->SetLineColor(kBlue);
    g18b->SetLineColor(kOrange+3);
    g18c->SetLineColor(kRed);
    g18d->SetLineColor(kBlack);
    g18a->SetTitle("");
    g18a->SetStats(0);

    g18a->GetXaxis()->SetRangeUser(x_min, x_max);
    g18b->GetXaxis()->SetRangeUser(x_min, x_max);
    g18c->GetXaxis()->SetRangeUser(x_min, x_max);
    g18d->GetXaxis()->SetRangeUser(x_min, x_max);

    g18a->Draw("Esame");
    g18b->Draw("Esame");
    g18c->Draw("Esame");
    g18d->Draw("Esame");

    TLegend* l18a = new TLegend(0.7, 0.65, 1.0, 0.9);
    l18a->AddEntry(g18a, "(40, 60) GeV/c", "l");
    l18a->AddEntry(g18b, "(60, 80) GeV/c", "l");
    l18a->AddEntry(g18c, "(80, 100) GeV/c", "l");
    l18a->AddEntry(g18d, "(100, 120) GeV/c", "l");
    l18a->Draw();

    ks->SaveAs("Hadrons_pt_intervals.png");

    TH1 *g18aa= dynamic_cast<TH1*>(f1->Get("hE2C_sum_vs_dr12_scaledpi1"));
    TH1 *g18bb= dynamic_cast<TH1*>(f1->Get("hE2C_sum_vs_dr12_scaledpi2"));
    TH1 *g18cc= dynamic_cast<TH1*>(f1->Get("hE2C_sum_vs_dr12_scaledpi3"));
    TH1 *g18dd= dynamic_cast<TH1*>(f1->Get("hE2C_sum_vs_dr12_scaledpi4"));


    //------------------------------------------------------------
    //Histograms EEC for splittings
    //------------------------------------------------------------

    TH1 *g19az0= dynamic_cast<TH1*>(f1->Get("hSplitE2C_sum_vs_dr12pi1"));
    TH1 *g19bz0= dynamic_cast<TH1*>(f1->Get("hSplitE2C_sum_vs_dr12pi2"));
    TH1 *g19cz0= dynamic_cast<TH1*>(f1->Get("hSplitE2C_sum_vs_dr12pi3"));
    TH1 *g19dz0= dynamic_cast<TH1*>(f1->Get("hSplitE2C_sum_vs_dr12pi4"));
    TH1 *g19az0_d2= dynamic_cast<TH1*>(f1->Get("hSplitE2C_sum_vs_dr12def2pi1"));
    TH1 *g19bz0_d2= dynamic_cast<TH1*>(f1->Get("hSplitE2C_sum_vs_dr12def2pi2"));
    TH1 *g19cz0_d2= dynamic_cast<TH1*>(f1->Get("hSplitE2C_sum_vs_dr12def2pi3"));
    TH1 *g19dz0_d2= dynamic_cast<TH1*>(f1->Get("hSplitE2C_sum_vs_dr12def2pi4"));

    TH1 *g19az1= dynamic_cast<TH1*>(f1->Get("hSplitZcut1E2C_sum_vs_dr12pi1"));
    TH1 *g19bz1= dynamic_cast<TH1*>(f1->Get("hSplitZcut1E2C_sum_vs_dr12pi2"));
    TH1 *g19cz1= dynamic_cast<TH1*>(f1->Get("hSplitZcut1E2C_sum_vs_dr12pi3"));
    TH1 *g19dz1= dynamic_cast<TH1*>(f1->Get("hSplitZcut1E2C_sum_vs_dr12pi4"));
    TH1 *g19az1_d2= dynamic_cast<TH1*>(f1->Get("hSplitZcut1E2C_sum_vs_dr12def2pi1"));
    TH1 *g19bz1_d2= dynamic_cast<TH1*>(f1->Get("hSplitZcut1E2C_sum_vs_dr12def2pi2"));
    TH1 *g19cz1_d2= dynamic_cast<TH1*>(f1->Get("hSplitZcut1E2C_sum_vs_dr12def2pi3"));
    TH1 *g19dz1_d2= dynamic_cast<TH1*>(f1->Get("hSplitZcut1E2C_sum_vs_dr12def2pi4"));

    TH1 *g19az2= dynamic_cast<TH1*>(f1->Get("hSplitZcut2E2C_sum_vs_dr12pi1"));
    TH1 *g19bz2= dynamic_cast<TH1*>(f1->Get("hSplitZcut2E2C_sum_vs_dr12pi2"));
    TH1 *g19cz2= dynamic_cast<TH1*>(f1->Get("hSplitZcut2E2C_sum_vs_dr12pi3"));
    TH1 *g19dz2= dynamic_cast<TH1*>(f1->Get("hSplitZcut2E2C_sum_vs_dr12pi4"));
    TH1 *g19az2_d2= dynamic_cast<TH1*>(f1->Get("hSplitZcut2E2C_sum_vs_dr12def2pi1"));
    TH1 *g19bz2_d2= dynamic_cast<TH1*>(f1->Get("hSplitZcut2E2C_sum_vs_dr12def2pi2"));
    TH1 *g19cz2_d2= dynamic_cast<TH1*>(f1->Get("hSplitZcut2E2C_sum_vs_dr12def2pi3"));
    TH1 *g19dz2_d2= dynamic_cast<TH1*>(f1->Get("hSplitZcut2E2C_sum_vs_dr12def2pi4"));

    TH1 *g19as= dynamic_cast<TH1*>(f1->Get("hSplitE2C_sum_vs_dr12_scaledpi1"));
    TH1 *g19bs= dynamic_cast<TH1*>(f1->Get("hSplitE2C_sum_vs_dr12_scaledpi2"));
    TH1 *g19cs= dynamic_cast<TH1*>(f1->Get("hSplitE2C_sum_vs_dr12_scaledpi3"));
    TH1 *g19ds= dynamic_cast<TH1*>(f1->Get("hSplitE2C_sum_vs_dr12_scaledpi4"));
    TH1 *g19as_d2= dynamic_cast<TH1*>(f1->Get("hSplitE2C_sum_vs_dr12_scaledpi1_d2"));
    TH1 *g19bs_d2= dynamic_cast<TH1*>(f1->Get("hSplitE2C_sum_vs_dr12_scaledpi2_d2"));
    TH1 *g19cs_d2= dynamic_cast<TH1*>(f1->Get("hSplitE2C_sum_vs_dr12_scaledpi3_d2"));
    TH1 *g19ds_d2= dynamic_cast<TH1*>(f1->Get("hSplitE2C_sum_vs_dr12_scaledpi4_d2"));

    TH1 *g19az1s= dynamic_cast<TH1*>(f1->Get("hSplitZcut1E2C_sum_vs_dr12_scaledpi1"));
    TH1 *g19bz1s= dynamic_cast<TH1*>(f1->Get("hSplitZcut1E2C_sum_vs_dr12_scaledpi2"));
    TH1 *g19cz1s= dynamic_cast<TH1*>(f1->Get("hSplitZcut1E2C_sum_vs_dr12_scaledpi3"));
    TH1 *g19dz1s= dynamic_cast<TH1*>(f1->Get("hSplitZcut1E2C_sum_vs_dr12_scaledpi4"));
    TH1 *g19az1s_d2= dynamic_cast<TH1*>(f1->Get("hSplitZcut1E2C_sum_vs_dr12_scaledpi1_d2"));
    TH1 *g19bz1s_d2= dynamic_cast<TH1*>(f1->Get("hSplitZcut1E2C_sum_vs_dr12_scaledpi2_d2"));
    TH1 *g19cz1s_d2= dynamic_cast<TH1*>(f1->Get("hSplitZcut1E2C_sum_vs_dr12_scaledpi3_d2"));
    TH1 *g19dz1s_d2= dynamic_cast<TH1*>(f1->Get("hSplitZcut1E2C_sum_vs_dr12_scaledpi4_d2"));

    TH1 *g19az2s= dynamic_cast<TH1*>(f1->Get("hSplitZcut2E2C_sum_vs_dr12_scaledpi1"));
    TH1 *g19bz2s= dynamic_cast<TH1*>(f1->Get("hSplitZcut2E2C_sum_vs_dr12_scaledpi2"));
    TH1 *g19cz2s= dynamic_cast<TH1*>(f1->Get("hSplitZcut2E2C_sum_vs_dr12_scaledpi3"));
    TH1 *g19dz2s= dynamic_cast<TH1*>(f1->Get("hSplitZcut2E2C_sum_vs_dr12_scaledpi4"));
    TH1 *g19az2s_d2= dynamic_cast<TH1*>(f1->Get("hSplitZcut2E2C_sum_vs_dr12_scaledpi1_d2"));
    TH1 *g19bz2s_d2= dynamic_cast<TH1*>(f1->Get("hSplitZcut2E2C_sum_vs_dr12_scaledpi2_d2"));
    TH1 *g19cz2s_d2= dynamic_cast<TH1*>(f1->Get("hSplitZcut2E2C_sum_vs_dr12_scaledpi3_d2"));
    TH1 *g19dz2s_d2= dynamic_cast<TH1*>(f1->Get("hSplitZcut2E2C_sum_vs_dr12_scaledpi4_d2"));

    //------------------------------------------------------------
    //                  FITTING
    //------------------------------------------------------------

    TH1 *Pt_av= dynamic_cast<TH1*>(f1->Get("Pt_averages"));
    
    std::vector<double> pt_av = {46.8391, 67.55, 87.9418, 108.261}; //average pt's per pt interval
    
    //For hadrons 
                                                                                                                //Higer pt fits
    auto [sdrpi0_hadrons, sdrpi0_hadrons_er] = GausFit(g18a, pt_av[0], "fit_hadrons_pt[0].png", 0.4, 0.4, 0.07); //0.45, 0.45, 0.02 
    auto [sdrpi1_hadrons, sdrpi1_hadrons_er] = GausFit(g18b, pt_av[1], "fit_hadrons_pt[1].png", 0.4, 0.4, 0.07); //0.3, 0.3, 0.02
    auto [sdrpi2_hadrons, sdrpi2_hadrons_er] = GausFit(g18c, pt_av[2], "fit_hadrons_pt[2].png", 0.45, 0.45, 0.06);//0.5, 0.5, 0.015
    auto [sdrpi3_hadrons, sdrpi3_hadrons_er] = GausFit(g18d, pt_av[3], "fit_hadrons_pt[3].png",  0.4, 0.4, 0.03); //0.5, 0.5, 0.01


    std::vector<double> sdrpeak_hadr = {sdrpi0_hadrons, sdrpi1_hadrons, sdrpi2_hadrons, sdrpi3_hadrons};
    std::vector<double> sdrpeak_hadr_er = {sdrpi0_hadrons_er, sdrpi1_hadrons_er, sdrpi2_hadrons_er, sdrpi3_hadrons_er};
    auto [finalsdrpeak_hadr, finalsdrpeak_hadr_er] = LinearFit(pt_av, sdrpeak_hadr, sdrpeak_hadr_er, "LinearFit_hadrons.png", 0.55, 0.85);
    
   //For splittings Zcut 0
   //Def 1 
    auto [sdrpi0_split_zcut0, sdrpi0_split_zcut0_er] = GausFit(g19az0, pt_av[0], "fit_splitzcut0_pt[0].png", 0.35,  0.35, 0.042); //0.7,  0.7, 0.018
    auto [sdrpi1_split_zcut0, sdrpi1_split_zcut0_er] = GausFit(g19bz0, pt_av[1], "fit_splitzcut0_pt[1].png", 0.45, 0.45, 0.038); //0.6, 0.6, 0.015
    auto [sdrpi2_split_zcut0, sdrpi2_split_zcut0_er] = GausFit(g19cz0, pt_av[2], "fit_splitzcut0_pt[2].png", 0.7, 0.7, 0.025); //0.9, 0.9, 0.01
    auto [sdrpi3_split_zcut0, sdrpi3_split_zcut0_er] = GausFit(g19dz0, pt_av[3], "fit_splitzcut0_pt[3].png", 0.5, 0.7, 0.012); //0.95, 0.95, 0.01

    std::vector<double> sdrpeak_zcut0 = {sdrpi0_split_zcut0, sdrpi1_split_zcut0, sdrpi2_split_zcut0, sdrpi3_split_zcut0}; // scaled dr peak for pt intervals
    std::vector<double> sdrpeak_zcut0_er = {sdrpi0_split_zcut0_er, sdrpi1_split_zcut0_er, sdrpi2_split_zcut0_er, sdrpi3_split_zcut0_er}; // scaled dr peak for pt intervals
    auto [finalsdrp_split_zcut0, finalsdrp_split_zcut0_er] = LinearFit(pt_av, sdrpeak_zcut0, sdrpeak_zcut0_er, "LinearFit_split_zcut0.png", 0.15, 0.25);
    //Def2
    auto [sdrpi0_split_zcut0_d2, sdrpi0_split_zcut0_d2_er] = GausFit(g19az0_d2, pt_av[0], "fit_splitzcut0_pt_def2[0].png",  0.35, 0.35, 0.09); //0.42, 0.42, 0.026
    auto [sdrpi1_split_zcut0_d2, sdrpi1_split_zcut0_d2_er] = GausFit(g19bz0_d2, pt_av[1], "fit_splitzcut0_pt_def2[1].png", 0.5, 0.5, 0.07); //0.7, 0.7, 0.022
    auto [sdrpi2_split_zcut0_d2, sdrpi2_split_zcut0_d2_er] = GausFit(g19cz0_d2, pt_av[2], "fit_splitzcut0_pt_def2[2].png", 0.55, 0.55, 0.05); //0.55, 0.55, 0.018
    auto [sdrpi3_split_zcut0_d2, sdrpi3_split_zcut0_d2_er] = GausFit(g19dz0_d2, pt_av[3], "fit_splitzcut0_pt_def2[3].png",  0.7, 0.7, 0.025); // 0.7, 0.7, 0.014


    std::vector<double> sdrpeak_zcut0_d2 = {sdrpi0_split_zcut0_d2, sdrpi1_split_zcut0_d2, sdrpi2_split_zcut0_d2, sdrpi3_split_zcut0_d2}; // scaled dr peak for pt intervals
    std::vector<double> sdrpeak_zcut0_d2_er = {sdrpi0_split_zcut0_d2_er, sdrpi1_split_zcut0_d2_er, sdrpi2_split_zcut0_d2_er, sdrpi3_split_zcut0_d2_er}; // scaled dr peak for pt intervals
    auto [finalsdrp_split_zcut0_d2, finalsdrp_split_zcut0_d2_er] = LinearFit(pt_av, sdrpeak_zcut0_d2, sdrpeak_zcut0_d2_er, "LinearFit_split_zcut0_def2.png", 0.15, 0.25);
    
    //For splittings Zcut 1
    //Def 1 
    auto [sdrpi0_split_zcut1, sdrpi0_split_zcut1_er] = GausFit(g19az1, pt_av[0], "fit_splitzcut1_pt[0].png", 0.5, 0.5, 0.043); // 0.42, 0.42, 0.012
    auto [sdrpi1_split_zcut1, sdrpi1_split_zcut1_er] = GausFit(g19bz1, pt_av[1], "fit_splitzcut1_pt[1].png", 0.45, 0.45, 0.025); //0.58, 0.58, 0.012
    auto [sdrpi2_split_zcut1, sdrpi2_split_zcut1_er] = GausFit(g19cz1, pt_av[2], "fit_splitzcut1_pt[2].png", 0.7, 0.7, 0.022); //0.4, 0.4, 0.011
    auto [sdrpi3_split_zcut1, sdrpi3_split_zcut1_er] = GausFit(g19dz1, pt_av[3], "fit_splitzcut1_pt[3].png", 0.7, 0.7, 0.02); //0.82, 0.82, 0.01
    

    std::vector<double> sdrpeak_zcut1 = {sdrpi0_split_zcut1, sdrpi1_split_zcut1, sdrpi2_split_zcut1, sdrpi3_split_zcut1}; // scaled dr peak for pt intervals
    std::vector<double> sdrpeak_zcut1_er = {sdrpi0_split_zcut1_er, sdrpi1_split_zcut1_er, sdrpi2_split_zcut1_er, sdrpi3_split_zcut1_er}; // scaled dr peak for pt intervals
    auto [finalsdrp_split_zcut1, finalsdrp_split_zcut1_er] = LinearFit(pt_av, sdrpeak_zcut1, sdrpeak_zcut1_er, "LinearFit_split_zcut1.png", 0.15, 0.25);
    
    //Def2
    auto [sdrpi0_split_zcut1_d2, sdrpi0_split_zcut1_d2_er] = GausFit(g19az1_d2, pt_av[0], "fit_splitzcut1_pt_def2[0].png", 0.4, 0.4, 0.085); //0.6, 0.6, 0.023
    auto [sdrpi1_split_zcut1_d2, sdrpi1_split_zcut1_d2_er] = GausFit(g19bz1_d2, pt_av[1], "fit_splitzcut1_pt_def2[1].png", 0.4, 0.4, 0.06); // 0.6, 0.6, 0.021
    auto [sdrpi2_split_zcut1_d2, sdrpi2_split_zcut1_d2_er] = GausFit(g19cz1_d2, pt_av[2], "fit_splitzcut1_pt_def2[2].png", 0.5, 0.5, 0.042); //0.66, 0.66, 0.02
    auto [sdrpi3_split_zcut1_d2, sdrpi3_split_zcut1_d2_er] = GausFit(g19dz1_d2, pt_av[3], "fit_splitzcut1_pt_def2[3].png",  0.6, 0.6, 0.03); //0.65, 0.65, 0.019
    

    std::vector<double> sdrpeak_zcut1_d2 = {sdrpi0_split_zcut1_d2, sdrpi1_split_zcut1_d2, sdrpi2_split_zcut1_d2, sdrpi3_split_zcut1_d2}; // scaled dr peak for pt intervals
    std::vector<double> sdrpeak_zcut1_d2_er = {sdrpi0_split_zcut1_d2_er, sdrpi1_split_zcut1_d2_er, sdrpi2_split_zcut1_d2_er, sdrpi3_split_zcut1_d2_er}; // scaled dr peak for pt intervals
    auto [finalsdrp_split_zcut1_d2, finalsdrp_split_zcut1_d2_er] = LinearFit(pt_av, sdrpeak_zcut1_d2, sdrpeak_zcut1_d2_er, "LinearFit_split_zcut1_def2.png", 0.15, 0.25);
    
     //For splittings Zcut 2
    //Def 1 
    auto [sdrpi0_split_zcut2, sdrpi0_split_zcut2_er] = GausFit(g19az2, pt_av[0], "fit_splitzcut2_pt[0].png", 0.4, 0.4, 0.038); //0.45, 0.45, 0.012
    auto [sdrpi1_split_zcut2, sdrpi1_split_zcut2_er] = GausFit(g19bz2, pt_av[1], "fit_splitzcut2_pt[1].png", 0.45, 0.45, 0.022); //0.56, 0.56, 0.006
    auto [sdrpi2_split_zcut2, sdrpi2_split_zcut2_er] = GausFit(g19cz2, pt_av[2], "fit_splitzcut2_pt[2].png",  0.4, 0.4, 0.02); // 0.46, 0.46, 0.005
    auto [sdrpi3_split_zcut2, sdrpi3_split_zcut2_er] = GausFit(g19dz2, pt_av[3], "fit_splitzcut2_pt[3].png", 0.5, 0.5, 0.01); //0.62, 0.62, 0.004
    
    std::vector<double> sdrpeak_zcut2 = {sdrpi0_split_zcut2, sdrpi1_split_zcut2, sdrpi2_split_zcut2, sdrpi3_split_zcut2}; // scaled dr peak for pt intervals
    std::vector<double> sdrpeak_zcut2_er = {sdrpi0_split_zcut2_er, sdrpi1_split_zcut2_er, sdrpi2_split_zcut2_er, sdrpi3_split_zcut2_er}; // scaled dr peak for pt intervals
    auto [finalsdrp_split_zcut2, finalsdrp_split_zcut2_er] = LinearFit(pt_av, sdrpeak_zcut2, sdrpeak_zcut2_er, "LinearFit_split_zcut2.png");
    
    //Def2
    auto [sdrpi0_split_zcut2_d2, sdrpi0_split_zcut2_d2_er] = GausFit(g19az2_d2, pt_av[0], "fit_splitzcut2_pt_def2[0].png", 0.4, 0.4, 0.075); //0.5, 0.5, 0.021
    auto [sdrpi1_split_zcut2_d2, sdrpi1_split_zcut2_d2_er] = GausFit(g19bz2_d2, pt_av[1], "fit_splitzcut2_pt_def2[1].png", 0.4, 0.4, 0.024); //0.5, 0.5, 0.02
    auto [sdrpi2_split_zcut2_d2, sdrpi2_split_zcut2_d2_er] = GausFit(g19cz2_d2, pt_av[2], "fit_splitzcut2_pt_def2[2].png", 0.55, 0.55, 0.02); //0.5, 0.5, 0.02
    auto [sdrpi3_split_zcut2_d2, sdrpi3_split_zcut2_d2_er] = GausFit(g19dz2_d2, pt_av[3], "fit_splitzcut2_pt_def2[3].png", 0.45, 0.45, 0.008); //0.65, 0.65, 0.008

    std::vector<double> sdrpeak_zcut2_d2 = {sdrpi0_split_zcut2_d2, sdrpi1_split_zcut2_d2, sdrpi2_split_zcut2_d2, sdrpi3_split_zcut2_d2}; // scaled dr peak for pt intervals
    std::vector<double> sdrpeak_zcut2_d2_er = {sdrpi0_split_zcut2_d2_er, sdrpi1_split_zcut2_d2_er, sdrpi2_split_zcut2_d2_er, sdrpi3_split_zcut2_d2_er}; // scaled dr peak for pt intervals
    auto [finalsdrp_split_zcut2_d2, finalsdrp_split_zcut2_d2_er] = LinearFit(pt_av, sdrpeak_zcut2_d2, sdrpeak_zcut2_d2_er, "LinearFit_split_zcut2_def2.png", 0.15, 0.2);
    
    std::cout << "Final scaled dr peak hadrons " << finalsdrpeak_hadr << " ± " << finalsdrpeak_hadr_er << std::endl;
    std::cout << "Final scaled dr peak splittings(zcut0) " << finalsdrp_split_zcut0 << " ± " << finalsdrp_split_zcut0_er << std::endl;
    std::cout << "Final scaled dr peak splittings def2 (zcut0) " << finalsdrp_split_zcut0_d2 << " ± " << finalsdrp_split_zcut0_d2_er << std::endl;
    std::cout << "Final scaled dr peak splittings(zcut1) " << finalsdrp_split_zcut1 << " ± " << finalsdrp_split_zcut1_er << std::endl;
    std::cout << "Final scaled dr peak splittings def2 (zcut1) " << finalsdrp_split_zcut1_d2 << " ± " << finalsdrp_split_zcut1_d2_er << std::endl;
    std::cout << "Final scaled dr peak splittings(zcut2) " << finalsdrp_split_zcut2 << " ± " << finalsdrp_split_zcut2_er << std::endl;
    std::cout << "Final scaled dr peak splittings def2 (zcut2) " << finalsdrp_split_zcut2_d2 << " ± " << finalsdrp_split_zcut2_d2_er << std::endl;

    
    DrawEEC(g19az0, g19bz0, g19cz0, g19dz0,"EEC Per Pt Bin (No Zcut)","EEC_Split.png");
    DrawEEC(g19az0_d2, g19bz0_d2, g19cz0_d2, g19dz0_d2,"EEC Per Pt Bin (No Zcut def2)","EEC_Splitdef2.png");
    DrawEEC(g19az1, g19bz1, g19cz1, g19dz1,"EEC Per Pt Bin (Zcut1)","EEC_SplitZcut1.png");
    DrawEEC(g19az1_d2, g19bz1_d2, g19cz1_d2, g19dz1_d2,"EEC Per Pt Bin (Zcut1 def2)","EEC_SplitZcut1def2.png");
    DrawEEC(g19az2, g19bz2, g19cz2, g19dz2,"EEC Per Pt Bin (Zcut2)","EEC_SplitZcut2.png");
    DrawEEC(g19az2_d2, g19bz2_d2, g19cz2_d2, g19dz2_d2,"EEC Per Pt Bin (Zcut2 def2)","EEC_SplitZcut2def2.png");

    DrawScaledEEC(g19as, g19bs, g19cs, g19ds,"Scaled EEC Per Pt Bin (No Zcut)", "Scaled_EEC_Split.png", finalsdrp_split_zcut0, finalsdrp_split_zcut0_er);
    DrawScaledEEC(g19as_d2, g19bs_d2, g19cs_d2, g19ds_d2,"Scaled EEC Per Pt Bin (No Zcut def2)", "Scaled_EEC_Splitdef2.png", finalsdrp_split_zcut0_d2, finalsdrp_split_zcut0_d2_er);
    DrawScaledEEC(g19az1s, g19bz1s, g19cz1s, g19dz1s,"Scaled EEC Per Pt Bin (Zcut1)", "Scaled_EEC_SplitZcut1.png", finalsdrp_split_zcut1, finalsdrp_split_zcut1_er);
    DrawScaledEEC(g19az1s_d2, g19bz1s_d2, g19cz1s_d2, g19dz1s_d2,"Scaled EEC Per Pt Bin (Zcut1 def2)", "Scaled_EEC_SplitZcut1def2.png", finalsdrp_split_zcut1_d2, finalsdrp_split_zcut1_d2_er);
    DrawScaledEEC(g19az2s, g19bz2s, g19cz2s, g19dz2s,"Scaled EEC Per Pt Bin (Zcut2)", "Scaled_EEC_SplitZcut2.png", finalsdrp_split_zcut2, finalsdrp_split_zcut2_er);
    DrawScaledEEC(g19az2s_d2, g19bz2s_d2, g19cz2s_d2, g19dz2s_d2,"Scaled EEC Per Pt Bin (Zcut2 def2)", "Scaled_EEC_SplitZcut2def2.png", finalsdrp_split_zcut2_d2, finalsdrp_split_zcut2_d2_er);

    TCanvas *kss = new TCanvas("kss", "kss");
    kss->cd();
    kss->SetLogx();

    TH1F *frame = gPad->DrawFrame(0.3, 0, 100, g18aa->GetMaximum() * 1.1);
    frame->GetXaxis()->SetTitle("#LTp_{T}^{ch,jet}#GT R_{L} (GeV/c)");
    frame->GetYaxis()->SetTitle("#Sigma_{EEC}(R_{L})");

    
    TLine* peakLine = new TLine(finalsdrpeak_hadr, 0, finalsdrpeak_hadr, g18aa->GetMaximum());
    peakLine->SetLineColor(kGreen+4);
    peakLine->SetLineStyle(0); 
    peakLine->SetLineWidth(2); 
    peakLine->Draw(); 
    
    g18aa->SetLineColor(kBlue);
    g18bb->SetLineColor(kOrange+3);
    g18cc->SetLineColor(kRed);
    g18dd->SetLineColor(kBlack);
    
    g18aa->Draw("Esame");
    g18bb->Draw("Esame");
    g18cc->Draw("Esame");
    g18dd->Draw("Esame");

    TLatex latex; 
    latex.SetNDC();  
    latex.SetTextSize(0.04);  
    latex.SetTextFont(42);

    double x = 0.15; 
    double y = 0.85; 
    double lineX1 = x;            
    double lineX2 = x + 0.07;      
    TLine *line = new TLine(lineX1, y, lineX2, y); 
    line->SetNDC();            
    line->SetLineColor(kGreen+4);      
    line->SetLineWidth(2);        
    line->Draw();

    latex.SetTextSize(0.035);      
    TString fitText = Form("Peak = %.2f #pm %.2f", finalsdrpeak_hadr, finalsdrpeak_hadr_er);
    latex.DrawLatex(lineX2 + 0.02, y, fitText); 

    TLegend *l18as = new TLegend(0.7, 0.65, 1.0, 0.9);
    l18as->AddEntry(g18aa, "(40, 60) GeV/c", "l");
    l18as->AddEntry(g18bb, "(60, 80) GeV/c", "l");
    l18as->AddEntry(g18cc, "(80, 100) GeV/c", "l");
    l18as->AddEntry(g18dd, "(100, 120) GeV/c", "l");
    l18as->Draw();
    kss->SaveAs("Hadrons_pt_intervals_scaled.png");


    TH1 *ratio_01_pi1= dynamic_cast<TH1*>(f1->Get("ratio_EEC_zcut01_pi1"));
    TH1 *ratio_01_pi2= dynamic_cast<TH1*>(f1->Get("ratio_EEC_zcut01_pi2"));
    TH1 *ratio_01_pi3= dynamic_cast<TH1*>(f1->Get("ratio_EEC_zcut01_pi3"));
    TH1 *ratio_01_pi4= dynamic_cast<TH1*>(f1->Get("ratio_EEC_zcut01_pi4"));
    TH1 *ratio_02_pi1= dynamic_cast<TH1*>(f1->Get("ratio_EEC_zcut02_pi1"));
    TH1 *ratio_02_pi2= dynamic_cast<TH1*>(f1->Get("ratio_EEC_zcut02_pi2"));
    TH1 *ratio_02_pi3= dynamic_cast<TH1*>(f1->Get("ratio_EEC_zcut02_pi3"));
    TH1 *ratio_02_pi4= dynamic_cast<TH1*>(f1->Get("ratio_EEC_zcut02_pi4"));

    TH1 *ratio_01_pi1_d2= dynamic_cast<TH1*>(f1->Get("ratio_EEC_zcut01_pi1_d2"));
    TH1 *ratio_01_pi2_d2= dynamic_cast<TH1*>(f1->Get("ratio_EEC_zcut01_pi2_d2"));
    TH1 *ratio_01_pi3_d2= dynamic_cast<TH1*>(f1->Get("ratio_EEC_zcut01_pi3_d2"));
    TH1 *ratio_01_pi4_d2= dynamic_cast<TH1*>(f1->Get("ratio_EEC_zcut01_pi4_d2"));
    TH1 *ratio_02_pi1_d2= dynamic_cast<TH1*>(f1->Get("ratio_EEC_zcut02_pi1_d2"));
    TH1 *ratio_02_pi2_d2= dynamic_cast<TH1*>(f1->Get("ratio_EEC_zcut02_pi2_d2"));
    TH1 *ratio_02_pi3_d2= dynamic_cast<TH1*>(f1->Get("ratio_EEC_zcut02_pi3_d2"));
    TH1 *ratio_02_pi4_d2= dynamic_cast<TH1*>(f1->Get("ratio_EEC_zcut02_pi4_d2"));
    
    
    TCanvas *ka = new TCanvas("ka", "ka", 2000, 600); 
    ka->Divide(4, 1); 
    ka->cd(1);   
    gPad->SetLogx();
    ratio_01_pi1->SetStats(0);
    ratio_01_pi1->GetXaxis()->SetTitle("R_{L}");
    ratio_01_pi1->GetYaxis()->SetTitle("#Sigma_{EEC}_{Zcut}/#Sigma_{EEC} (R_{L})");
    ratio_01_pi1->GetXaxis()->SetRangeUser(1e-3, 0.4);  
    ratio_01_pi1->GetYaxis()->SetRangeUser(0., 2.);  
    ratio_01_pi1->SetTitle("Pt = (40, 60) Gev/c");
    ratio_01_pi1->SetLineColor(kRed);
    ratio_02_pi1->SetLineColor(kGreen+3);
    ratio_01_pi1->Draw("E"); 
    ratio_02_pi1->Draw("Esame");
  
    ka->cd(2);   
    gPad->SetLogx();
    ratio_01_pi2->SetStats(0);
    ratio_01_pi2->GetXaxis()->SetTitle("R_{L}");
    ratio_01_pi2->GetYaxis()->SetTitle("#Sigma_{EEC}_{Zcut}/#Sigma_{EEC} (R_{L})");
    ratio_01_pi2->GetXaxis()->SetRangeUser(1e-3, 0.4);  
    ratio_01_pi2->GetYaxis()->SetRangeUser(0., 2.);  
    ratio_01_pi2->SetTitle("Pt = (60, 80) Gev/c");
    ratio_01_pi2->SetLineColor(kRed);
    ratio_02_pi2->SetLineColor(kGreen+3);
    ratio_01_pi2->Draw("E"); 
    ratio_02_pi2->Draw("Esame");
   
    ka->cd(3);   
    gPad->SetLogx();
    ratio_01_pi3->SetStats(0);
    ratio_01_pi3->GetXaxis()->SetTitle("R_{L}");
    ratio_01_pi3->GetYaxis()->SetTitle("#Sigma_{EEC}_{Zcut}/#Sigma_{EEC} (R_{L})");
    ratio_01_pi3->GetXaxis()->SetRangeUser(1e-3, 0.4);  
    ratio_01_pi3->GetYaxis()->SetRangeUser(0., 2.);  
    ratio_01_pi3->SetTitle("Pt = (80, 100) Gev/c");
    ratio_01_pi3->SetLineColor(kRed);
    ratio_02_pi3->SetLineColor(kGreen+3);
    ratio_01_pi3->Draw("E"); 
    ratio_02_pi3->Draw("Esame");

    ka->cd(4);   
    gPad->SetLogx();
    ratio_01_pi4->SetStats(0);
    ratio_01_pi4->GetXaxis()->SetTitle("R_{L}");
    ratio_01_pi4->GetYaxis()->SetTitle("#Sigma_{EEC}_{Zcut}/#Sigma_{EEC} (R_{L})");
    ratio_01_pi4->GetXaxis()->SetRangeUser(1e-3, 0.4);  
    ratio_01_pi4->GetYaxis()->SetRangeUser(0., 2.);  
    ratio_01_pi4->SetTitle("Pt = (100, 120) Gev/c");
    ratio_01_pi4->SetLineColor(kRed);
    ratio_02_pi4->SetLineColor(kGreen+3);
    ratio_01_pi4->Draw("E"); 
    ratio_02_pi4->Draw("Esame");
   
    ka->SaveAs("ratios_zcuts_for_EEC.png");

    TCanvas *kad2 = new TCanvas("kad2", "kad2", 2000, 600); 
    kad2->Divide(4, 1);  
    kad2->cd(1);   
    gPad->SetLogx();
    ratio_01_pi1_d2->SetStats(0);
    ratio_01_pi1_d2->GetXaxis()->SetTitle("R_{L}");
    ratio_01_pi1_d2->GetYaxis()->SetTitle("#Sigma_{EEC}_{Zcut}/#Sigma_{EEC} (R_{L})");
    ratio_01_pi1_d2->GetXaxis()->SetRangeUser(1e-3, 0.4);  
    ratio_01_pi1_d2->GetYaxis()->SetRangeUser(0., 2.);  
    ratio_01_pi1_d2->SetTitle("Pt = (40, 60) Gev/c");
    ratio_01_pi1_d2->SetLineColor(kRed);
    ratio_02_pi1_d2->SetLineColor(kGreen+3);
    ratio_01_pi1_d2->Draw("E"); 
    ratio_02_pi1_d2->Draw("Esame");
  
    kad2->cd(2);   
    gPad->SetLogx();
    ratio_01_pi2_d2->SetStats(0);
    ratio_01_pi2_d2->GetXaxis()->SetTitle("R_{L}");
    ratio_01_pi2_d2->GetYaxis()->SetTitle("#Sigma_{EEC}_{Zcut}/#Sigma_{EEC} (R_{L})");
    ratio_01_pi2_d2->GetXaxis()->SetRangeUser(1e-3, 0.4);  
    ratio_01_pi2_d2->GetYaxis()->SetRangeUser(0., 2.);  
    ratio_01_pi2_d2->SetTitle("Pt = (60, 80) Gev/c");
    ratio_01_pi2_d2->SetLineColor(kRed);
    ratio_02_pi2_d2->SetLineColor(kGreen+3);
    ratio_01_pi2_d2->Draw("E"); 
    ratio_02_pi2_d2->Draw("Esame");
   
    kad2->cd(3);   
    gPad->SetLogx();
    ratio_01_pi3_d2->SetStats(0);
    ratio_01_pi3_d2->GetXaxis()->SetTitle("R_{L}");
    ratio_01_pi3_d2->GetYaxis()->SetTitle("#Sigma_{EEC}_{Zcut}/#Sigma_{EEC} (R_{L})");
    ratio_01_pi3_d2->GetXaxis()->SetRangeUser(1e-3, 0.4);  
    ratio_01_pi3_d2->GetYaxis()->SetRangeUser(0., 2.);  
    ratio_01_pi3_d2->SetTitle("Pt = (80, 100) Gev/c");
    ratio_01_pi3_d2->SetLineColor(kRed);
    ratio_02_pi3_d2->SetLineColor(kGreen+3);
    ratio_01_pi3_d2->Draw("E"); 
    ratio_02_pi3_d2->Draw("Esame");

    kad2->cd(4);   
    gPad->SetLogx();
    ratio_01_pi4_d2->SetStats(0);
    ratio_01_pi4_d2->GetXaxis()->SetTitle("R_{L}");
    ratio_01_pi4_d2->GetYaxis()->SetTitle("#Sigma_{EEC}_{Zcut}/#Sigma_{EEC} (R_{L})");
    ratio_01_pi4_d2->GetXaxis()->SetRangeUser(1e-3, 0.4);  
    ratio_01_pi4_d2->GetYaxis()->SetRangeUser(0., 2.);  
    ratio_01_pi4_d2->SetTitle("Pt = (100, 120) Gev/c");
    ratio_01_pi4_d2->SetLineColor(kRed);
    ratio_02_pi4_d2->SetLineColor(kGreen+3);
    ratio_01_pi4_d2->Draw("E"); 
    ratio_02_pi4_d2->Draw("Esame");
   
    kad2->SaveAs("ratios_zcuts_for_EEC_d2.png");
    

    std::string filePath = "/Volumes/D2/users/rosa/JetToyHI/working/HEPData-1730222927-v1-Figure_2.csv";
    int nBins = 50; 
    double xMin = 0.0; 
    double xMax = 1.0; 
    
    TH1* hist40_60 = new TH1D("hist40_60", "Histogram for pt range 40-60", nBins, xMin, xMax);
    TH1* hist60_80 = new TH1D("hist60_80", "Histogram for pt range 60-80", nBins, xMin, xMax);

    std::vector<DataPoint> data40_60 = readDataFromFile(filePath, "R_{L}$,40-60");
    std::vector<DataPoint> data60_80 = readDataFromFile(filePath, "R_{L}$,60-80");

    for (const auto& dp : data40_60) {
        double xValue = dp.Rl; 
        double yValue = dp.Sigma; 
        double xUncertainty = dp.sys_unc_plus * 2.0; 
        
        int bin = hist40_60->FindBin(xValue);
        hist40_60->SetBinContent(bin, yValue);
        hist40_60->SetBinError(bin, xUncertainty); 
    }
    for (const auto& dp : data60_80) {
        double xValue = dp.Rl; 
        double yValue = dp.Sigma; 
        double xUncertainty = dp.sys_unc_plus * 2.0; 
        
        int bin = hist60_80->FindBin(xValue);
        hist60_80->SetBinContent(bin, yValue);
        hist60_80->SetBinError(bin, xUncertainty); 
    }

    TFile* outFile = new TFile("histograms.root", "RECREATE");
    hist40_60->Write();
    hist60_80->Write();
    outFile->Close();
    
    
drawHistograms(g18a, g18b, hist40_60, hist60_80, "histograms.png", "\\#Sigma_{EEC}(R_{L})");

TH1F* hist40_60_clone = (TH1F*)hist40_60->Clone("hist40_60_clone_1");
TH1F* hist60_80_clone = (TH1F*)hist60_80->Clone("hist60_80_clone_1");
TH1F* g18a_clone = (TH1F*)g18a->Clone("g18a_clone_1");
TH1F* g18b_clone = (TH1F*)g18b->Clone("g18b_clone_1");

if (hist40_60_clone->Integral() > 0) hist40_60_clone->Scale(1.0 / hist40_60_clone->Integral());
if (hist60_80_clone->Integral() > 0) hist60_80_clone->Scale(1.0 / hist60_80_clone->Integral());
if (g18a_clone->Integral() > 0) g18a_clone->Scale(1.0 / g18a_clone->Integral());
if (g18b_clone->Integral() > 0) g18b_clone->Scale(1.0 / g18b_clone->Integral());

drawHistograms(g18a_clone, g18b_clone, hist40_60_clone, hist60_80_clone, "scaled_histograms.png", "\\Sigma_{EEC}(R_L) / \\int \\Sigma_{EEC}(R_L) dR_L" );

TH1F* hist40_60_clone2 = (TH1F*)hist40_60->Clone("hist40_60_clone_2");
TH1F* hist60_80_clone2 = (TH1F*)hist60_80->Clone("hist60_80_clone_2");
TH1F* g18a_clone2 = (TH1F*)g18a->Clone("g18a_clone_2");
TH1F* g18b_clone2 = (TH1F*)g18b->Clone("g18b_clone_2");

if (hist40_60_clone2->GetMaximum() > 0) hist40_60_clone2->Scale(1.0 / hist40_60_clone2->GetMaximum());
if (hist60_80_clone2->GetMaximum() > 0) hist60_80_clone2->Scale(1.0 / hist60_80_clone2->GetMaximum());
if (g18a_clone2->GetMaximum() > 0) g18a_clone2->Scale(1.0 / g18a_clone2->GetMaximum());
if (g18b_clone2->GetMaximum() > 0) g18b_clone2->Scale(1.0 / g18b_clone2->GetMaximum());

drawHistograms(g18a_clone2, g18b_clone2, hist40_60_clone2, hist60_80_clone2, "scaled2_histograms.png","\\Sigma_{EEC}(R_L) / \\text{max}(\\Sigma_{EEC})");









}